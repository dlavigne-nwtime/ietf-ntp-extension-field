<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC5905 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml">
<!ENTITY RFC5906 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5906.xml">
<!ENTITY RFC7821 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7821.xml">
<!ENTITY RFC2827 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2827.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2434 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2434.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-stenn-ntp-extension-fields-02" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="NTPv4 Extension Fields">Network Time Protocol Version 4 (NTPv4) Extension Fields
    </title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Tal Mizrahi" initials="T." surname="Mizrahi">
      <organization>Marvell</organization>

      <address>
        <postal>
          <street>6 Hamda St.</street>

          <!-- Reorder these if your country does things differently -->

          <city>Yokneam, 20692</city>

          <region/>

          <country>Israel</country>
        </postal>

        <phone/>

        <email>talmi@marvell.com</email>
      </address>
    </author>

    <author fullname="Danny Mayer" initials="D." surname="Mayer">
      <organization>Network Time Foundation</organization>

      <address>
        <postal>
          <street>P.O. Box 918</street>

          <!-- Reorder these if your country does things differently -->

          <city>Talent, OR</city>

          <region/>

          <code>97540</code>

          <country>US</country>
        </postal>

        <phone/>

        <email>mayer@ntp.org</email>
      </address>
    </author>

    <author fullname="Harlan Stenn" initials="H." surname="Stenn">
      <organization>Network Time Foundation</organization>

      <address>
        <postal>
          <street>P.O. Box 918</street>

          <!-- Reorder these if your country does things differently -->

          <city>Talent, OR</city>

          <region/>

          <code>97540</code>

          <country>US</country>
        </postal>

        <phone/>

        <email>stenn@nwtime.org</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

<!-- other authors -->

    <date month="September" year="2017"/>

    <!-- If the month and year are both specified and are the current ones,
         xml2rfc will fill in the current day for you. If only the current
         year is specified, xml2rfc will fill in the current day and month
         for you. If the year is not the current one, it is necessary to
         specify at least a month (xml2rfc assumes day="1" if not specified
         for the purpose of calculating the expiry date).  With drafts it is
         normally sufficient to specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working
         Group", which is used by the RFC Editor as a nod to the history of
         the IETF. -->

    <keyword>NTP</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t> Network Time Protocol version 4 (NTPv4) defines the optional usage
	of extension fields.  An extension field, as defined
	in <xref target="RFC5905">RFC 5905</xref>
	and <xref target="RFC5906">RFC 5906</xref>, resides after the end of
	the NTP header, and supplies optional capabilities or information
	that is not conveyed in the standard NTP header.  This document
	updates <xref target="RFC5905">RFC 5905</xref> by clarifying some
	points regarding NTP extension fields and their usage with legacy
	Message Authentication Codes (MACs).</t>

      <t>With the adoption of this update, the authors recommend rescinding
	[Err3627].</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The NTP header format consists of a set of fixed fields that may be
	followed by optional fields.  Two types of optional fields are
	defined: extension fields as defined in Section 7.5
	of <xref target="RFC5905">RFC 5905</xref>, and legacy Message
	Authentication Codes (legacy MACs).</t>

      <t>If a legacy MAC is used, it resides at the end of the packet.  This
	field can be either a 4-octet crypto-NAK or data that is usually 20
	or 24 octets long.</t>

      <t>Additional information about the content of a MAC is specifieded in
        <xref target="RFC5906">RFC 5906</xref>, but since that RFC is
	Informational an implementor that was not planning to provide
	Autokey would likely never read that document.  The result of this
	would be interoperability problems, at least.  To address this
	problem, this proposal also includes copying and clarifying some of
	the content of RFC 5906 and putting it into RFC 5905.  Because
	there is a reasonable chance RFC 5906 will be deprecated, this
	document does not propose changes to RFC 5906.</t>

      <t>NTP extension fields are defined in <xref target="RFC5905">RFC
	  5905</xref> as a generic mechanism that allows the addition of
	future extensions and features without modifying the NTP header
	format (Section 16 of <xref target="RFC5905">RFC 5905</xref>).</t>

      <t>Section 7.5 of <xref target="RFC5905">RFC 5905</xref> clearly
	states that "one or more extension fields can be inserted after
	the header and before the MAC, which is always present when an
	extension field is present."  However, the experimental Checksum
	Complement <xref target="RFC7821">RFC 7821</xref> cannot be used if
	the NTP packet contains a MAC.</t>

      <t>To allow for extension fields that do not require a MAC, changes to
	the NTPv4 specification must be made.  [Err3627] was an attempt to
	clarify the rules around MACs, but with the adoption of this
	proposal the authors recommend rescinding [Err3627].</t>

      <t>This document better specifies and clarifies extension fields as
	well as the requirements and parsing of a legacy MAC, with changes
	to address errors found after the publication
	of <xref target="RFC5905">RFC 5905</xref> with respect to extension
	fields.  Specifically, this document updates Section 7.5
	of <xref target="RFC5905">RFC 5905</xref>, clarifying the
	relationship between extension fields and MACs, and defines the
	behavior of a host that receives an unknown extension field.</t>
    </section>

    <section title="Conventions Used in This Document">
      <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
          NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"
          in this document are to be interpreted as described
          in <xref target="RFC2119">RFC 2119</xref>.</t>
      </section>

      <section title="Terms and Abbreviations">
        <t>MAC - Message Authentication Code</t>
	<t>NTPv4 - Network Time Protocol, Version
          4 <xref target="RFC5905">RFC 5905</xref></t>
      </section>
    </section>

    <section title="NTP MAC - RFC 5906 Update">
      <t>This document copies and updates some information
	in <xref target="RFC5906">RFC 5906</xref> and puts it in to RFC
	5905, as follows:</t>

      <section title="4. Autokey Cryptography">
        <t>This section describes some of the cryptography aspects of
          Autokey.  The third paragraph describes the use of 128- and
          160-bit message digests.  The enumeration of 128- and 160-bit
          message digests is not meant to be limiting - other message digest
          lengths MAY be implemented.  This paragraph also describes some of
          the recommended semantic ranges of the key ID.  This information
          belongs in RFC 5905.  The key ID ranges are particularly
          significant because they provide addtional disambiguation
          protection when deciding if the next data portion is either a
          legacy MAC or an extension field.</t>
      </section>

      <section title="10. Autokey Protocol Messages">
	<t>This section describes the extension field format, including
	  initial flag bits, a Code field, and 8-bit Field Type, and the
	  16-bit Length.  This proposal expands and clarifies this
	  information and puts it into RFC 5905.</t>

	<t>This section says "The reference implementation discards any
	  packet with a field length of more than 1024 characters." but this
	  is no longer true.</t>
      </section>

      <section title="11.5. Error Recovery">
	<t>This section describes the crypto-NAK, which should be described
	  in RFC 5905.</t>
      </section>

      <section title="13. IANA Consideration">
        <t>This section lists the Autokey-related Extension Field Types,
          including Flag Bits, Codes, and Field Types, which should be
          described in RFC 5905, or perhaps in some other document.</t>
      </section>
    </section>
      
    <section title="NTP Extension Fields - RFC 5905 Update">
      <t>This document updates Section 7.5 of <xref target="RFC5905">RFC
	  5905</xref> as follows:</t>

      <section title="OLD: 7.5 NTP Extension Field Format">
	<t>In NTPv4, one or more extension fields can be inserted after the
	  header and before the MAC, which is always present when an
	  extension field is present.  Other than defining the field format,
	  this document makes no use of the field contents.  An extension
	  field contains a request or response message in the format shown
	  in Figure 14.</t>

      <t><figure title="Figure 14: Extension Field Format">
          <artwork name="Figure 14: Extension Field Format"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------------------------------+ 
|          Field Type           |        Field Length           |
+-------------------------------+-------------------------------+ 
.                                                               .
.                             Value                             .
.                                                               .
+-------------------------------+-------------------------------+ 
|                       Padding (as needed)                     | 
+---------------------------------------------------------------+]]></artwork>
        </figure></t>
      <t>All extension fields are zero-padded to a word (four octets)
	boundary.  The Field Type field is specific to the defined function
	and is not elaborated here.  While the minimum field length
	containing required fields is four words (16 octets), a maximum
	field length remains to be established.</t>

      <t>The Length field is a 16-bit unsigned integer that indicates the
	length of the entire extension field in octets, including the
	Padding field.</t>
      </section>

      <section title="NEW: 7.5 NTP Extension Field Format">
	<t>In NTPv4, one or more extension fields can be inserted after the
	  header and before the possibly optional legacy MAC.  A MAC SHOULD
	  be present when an extension field is present.  A MAC is always
	  present in some form when NTP packets are authenticated.  This MAC
	  SHOULD be either a legacy MAC or a MAC-EF.  It MAY be both.  Other
	  than defining the field format, this document makes no use of the
	  field contents.  An extension field contains a request or response
	  message in the format shown in Figure 14.</t>

      <t><figure title="Figure 14: Extension Field Format">
          <artwork name="Figure 14: Extension Field Format"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------------------------------+ 
|          Field Type           |        Field Length           |
+-------------------------------+-------------------------------+ 
.                                                               .
.                             Value                             .
.                                                               .
+-------------------------------+-------------------------------+ 
|                       Padding (as needed)                     | 
+---------------------------------------------------------------+]]></artwork>
        </figure></t>
      <t>All extension fields are zero-padded to a word (four octet)
	boundary.  The Field Type is specific to the defined function and
	detailed information about the Field Type is not elaborated here.
	The minimum size of an Extension Field is a 32-bit word (4 octets),
	and while the maximum extension field size MUST be 65532 octets or
	less, an NTP packet SHOULD NOT exceed the network MTU.</t>

      <t>The Length field is a 16-bit unsigned integer that indicates the
	length of the entire extension field in octets, including any
	Padding octets.  The bottom two bits of the Field Length SHOULD be
	zero.</t>

      <t>The Field Type contains the following sub-elements:</t>
      <t><figure title="Field Type Format">
          <artwork name="Field Type Format"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------+---------------+-------------------------------+ 
|R|E|O|I|  Code |       Type    |       (Field Length)          |
+-------------------------------+-------------------------------+]]></artwork>
        </figure></t>
      <t>Where the following Field Type flags are defined:
      <list>
	<t> R: 0 for a "Query", 1 for a "Response"</t>
	<t> E: 0 for "OK", 1 for an "Error"</t>
	<t> O: 0 for "MAC Required", 1 for "MAC Optional"</t>
	<t> I: 0 for "MAC Not Included", 1 for "MAC Included"</t>
      </list></t>

      <t>[The EF Code subtype is currently only used
	by <xref target="RFC5906">RFC 5906, Autokey</xref>.  The EF Code
	subtype is expected to be used by the NTS Extension Field, and the
	Extended Information Extension Field, at least.]</t>

      <t>The Field Type, Value, and Padding fields are specific to the
	defined function and are not elaborated here; appropriate Field Type
	flags, the EF Code, and EF Type values are defined in an IANA
	registry, and the Length, Value, and Padding values are defined by
	the document referred to by the registry.  If a host receives an
	extension field with an unknown Field Type, the host SHOULD ignore
	the extension field and MAY drop the packet altogether if policy
	requires it.</t>

      <t>The Length field is a 16-bit unsigned integer that indicates the
	length of the entire extension field in octets, including any
	Padding.</t>

      <t>While the minimum field length containing required fields is four
	words (16 octets), the maximum field length MUST NOT be longer than
	65532 octets due to the maximum size of the data represented by the
	Length field, and SHOULD be small enough that the size of the NTP
	packet received by the client does not exceed the smallest MTU
	between the sender and the recipient.  The bottom two bits of the
	Field Length SHOULD be zero.</t>
      </section>

      <section title="NEW: 7.5.1 Extension Fields and MACs">
	<t>With the inclusion of additional Extension Fields, there is now a
	  possibility of an ambiguous parsing in the presence of a legacy MAC.
	  If an implementation offers even a modicum of care, there will be no
	  ambiguity when parsing an NTP packet that contains a legacy MAC
	  from an existing implementation.
	</t>

	<t>The first protection from this ambiguity comes from the fact that
	  current conforming implementations only support the Autokey EF,
	  which uses EF Type 2 and a legacy MAC.  While the Experimental UDP
	  Checksum Complement specified by <xref target="RFC7821">RFC
	  7821</xref> uses EF Type 5, it specifically prohibits the use of a
	  MAC, and the 0x2000 bit in its assigned EF type of 0x2005
	  specifies that a MAC is optional when this EF is provided.</t>

	<t>[As a side note, the requirement in <xref target="RFC7821">RFC
	7821</xref> that the UDP Checksum Complement EF must have a 28 octet
	length is demonstrably not needed if this proposal is accepted.  It
	only needs 8 octets: 4 octets of EF header, 2 octets of MBZ padding,
	and 2  octets of Checksum Complement.]</t>

	<t>If an implementation uses the LAST-EF extension field, the
	  presence of this field means "I am the last EF in this NTP Packet.
	  Any subsequent packet data MUST be a legacy MAC."  In this case,
	  there is no parsing ambiguity.</t>

	<t>If a system sends its MAC as a MAC-EF and does not send a legacy
	  MAC, there is no parsing ambiguity.</t>

	<t>The only time there is a potential for a parsing ambiguity is
	  when a legacy MAC is provided and neither of the previous two
	  cases are present.  Even in this case, there is minimal risk.</t>

	<t>An Extension Field contains a 2-octet Field Type, a 2-octet Field
	  Length, and any payload (data and/or padding).  If the NTP Packet
	  parsing is at a point where it is evaluating data after the base
	  packet, one of the following situations exists:
	  <list>
	    <t>If the Field Length is not an even multiple of 4, we are not
	      looking at an extension field.  In this case, the only
	      possibility of having a valid packet is if the data is part of
	      a legacy MAC.</t>
	    <t>If the Field Length is valid, i.e., an even multiple of 4
	      octets, one of the following three cases must be present:
	      <list>
		<t>First, the Field Length will be less than the remaining
		  data.  This means subsequent data must parse as some
		  number of Extension Fields, optionally follwed by a legacy
		  MAC.</t>
		<t>Second, the Field Length will exactly match the
		  remaining data.</t>
		<t>The third case is where the Field Length is longer than
		  the remaining packet data.  In this case, the current
		  parse cannot be a valid extension field, and if the packet
		  is valid, the data must be a legacy MAC.</t>
		</list></t>
	    </list></t>

	<t>Semantic checking may also be done to validate a potential legacy
	  MAC.  A legacy MAC is a four-octet Key Identifier followed by a
	  message digest.  The usual message digest is 16 octets long but
	  may be another size, depending on the digest algorithm.  In the
	  Reference Implementation, a Key Identifier between 1 and 65535,
	  inclusive, is a symmetric key, while a Key Identifier that is >
	  65535 is an Autokey <xref target="RFC5906">RFC 5906</xref>, or
	  similar.  If the receiving system does not recognize the Key
	  Identifier, the data CANNOT be a valid legacy MAC.  If the
	  receiving system recognizes the Key Identifier, then it also has
	  knowledge of the digest algorithm and can make sure the digest
	  payload is the proper length.  If this is not the case, then the
	  data CANNOT be a valid legacy MAC.  In this case, it MIGHT be a
	  valid extension field.</t>

	<t>It is trivial to parse the data after the base NTP packet and
	  come up with a list of potential parsings.  A local policy choice
	  can specify the precedence of the parsing options in this
	  case.</t>

	<t>If none of the parsings validate, the packet fails
	  authentication.  An implementation has three local policy choices
	  available if LAST-EF is not used and a legacy MAC may be provided.
	  First, the implementation may specify EF-precedence.  Second, the
	  implementation may specify legacy-MAC-precedence.  Finally, the
	  implementation may specify "best fit" precedence.  In this last
	  case, the packet will meet one of the three following criteria:
	  First, none of the parsings will match.  Again, this is a case of
	  failed authentication.  Second, exactly one parsing will match and
	  that parsing will be accepted.  Third, multiple parsings will
	  match, in which case the implementation may choose its
	  behavior.</t>

	<t>Additionally, most EFs will require a MAC.  If there is a
	  syntactically-valid parsing that does not include a MAC but
	  previously scanned EFs require a MAC, then in a multiple-choice
	  parsing scenario where one of the choices does not include a MAC
	  the "no MAC provided" choice SHOULD be eliminated.</t>

	<t>Note well that this rare situation can be completely avoided by
	  using LAST-EF, or by indicating that no legacy MAC will be
	  used.</t>
	<section title="Legacy MAC/EF Parsing Pseudocode">
	  <t>Here are two potential pseudocode implementations showing how
	    data after the base NTP packet could be analyzed to identify EFs
	    and a possible legacy MAC.</t>

	  <t>Example 1: Generate a list of possible parsings:</t>
          <t><figure title="Example 1: Generate a list of possible
          parsings">
	      <artwork name="Generate a list of possible parsings"><![CDATA[
struct pkt_parse {
 foo * ef_ptr;
 foo * legacy_mac;
 struct pkt_parse * next;
};

struct pkt_parse pkt_parse_chain = NULL;

EOPacket = address of last data in packet;
here = address of the EOBasePacket;
more_efs = 1;
while (1) {
    int candidate = 0;
    int ef_len = 0;

    if (EOPacket > here) {
        p = emalloc(pkt_parse);			// assumes p is "cleared" data
        if (this could be a legacy MAC) {	// we know the keyid
            p->legacy_mac = here;
            candidate = 1;
        }
        if (more_efs && this could be an EF) {	// ie length field valid
            p->ef_ptr = here;
            ef_len = (the length of the EF);
            here += ef_len;
            if (this is a LAST_EF) {
                more_efs = 0;
            }
            candidate = 1;
        } else {
            more_efs = 0;
        }
    }

    if (candidate) {
        p->next = pkt_parse_chain;
        pkt_parse_chain = p;
    } else {
        free(p);
        break;
    }
}]]></artwork></figure></t>

	  <t>and at this point we can scan thru the items in pkt_parse_chain to
	    do deeper checks, throwing away the parsings that don't make
	    sense.</t>

	  <t>This opens up more questions if we get multiple parsings and at
	    least 1 of them is "valid".  It's also perfectly reasonable to
	    decide to produce a single parse based on precedence rules:
	    Prefer legacy MAC, or prefer EF.</t>

	  <t>Example 2: Another possible way to handle EF/legacy-MAC parsing:</t>

          <t><figure title="Example 2: Another possible way to handle
			    EF/legacy-MAC parsing">
	      <artwork><![CDATA[
// We're at the end of the base NTP packet.
// A legacy MAC is allowed:
// - immediately after the base packet
// - immediately after one or more Autokey EFs(a non-issue, below)
// - immediately after a LAST-EF

ef_ok = 1;				// an EF is allowed here
legacy_mac_ok = 1;			// A legacy MAC is allowed here
req_mac = 0;				// A MAC is not required
saw_mac = 0;				// We haven't seen a MAC yet
authlen = LEN_PKT_NOMAC;		// Length of a base packet
leg_mac = rbufp->recv_length - authlen;	// # bytes after base

while (leg_mac > 0) {			// There is more stuff after the base packet
	if (leg_mac % 4 != 0 || leg_mac < MIN_MAC_LEN) {
		return: Bad packet length;
	}

	// If ef_ok, this could be an EF or legacy MAC
	skeyid = ntohl(pkt[authlen / 4];
	opcode = skeyid >> 16;
	len = skeyid & 0xffff;

	if (ef_ok && GET_EXT_FIELD_TYPE(opcode) == EF_FT_LAST) {
		if (leg_mac > MAX_MAC_LEN) {
			return: Too much data after LAST_EF;
		}
		// Anything here MUST be a legacy MAC
		ef_ok = 0;
		legacy_mac_ok = 1;
	} else {
		if (4 == leg_mac && 0 == skeyid) {
			break;// Likely crypto-NAK
		}

		if (legacy_mac_ok && leg_mac <= MAX_MAC_LEN) {
			int ksize;

			// From above: skeyid = ntohl(pkt[authlen / 4]);

			// If we find the keyid, we know its alg/length
			ksize = auth_findkeysize(skeyid);
			if (ksize != -1) {
				saw_mac = 1;
				break;
			}
			// If we didn't find it, this can't be a valid
			// legacy MAC.  It's still a potential EF.
		}

		if (!ef_ok) {
			break;
		}

		// At this point, this SHOULD be an EF

		if (   len % 4 != 0
		    || len < 4
		    || len + authlen > rbufp-> recv_length) {
			return: Bad length;
		}

		if (opcode & EF_FL_reoI) {	// EF contains MAC
			saw_mac = 1;		// Just a hint
		}
		if (opcode & EF_FL_reOi) {	// MAC optional
		} else {
			req_mac = 1;	// MAC required
		}
		switch (GET_EXT_FIELD_TYPE(opcode)) {
		case EF_FT_AK:		// Autokey
			// extract calling group name for later
			break;
		case EF_FT_LAST:	// LAST-EF
			legacy_mac_ok = 1;
			break;
		default:
			legacy_mac_ok = 0;
			break;
		}
	}

	authlen += len;
	leg_mac -= len;
}

if (leg_mac < 0) {
	return: Malformed packet
}]]></artwork></figure></t>
	</section>
      </section>

      <section title="OLD: 9.2. Peer Process Operations">
	<t>...</t>
	<t>FXMIT. ... This message includes the normal NTP header data shown
	  in Figure 8, but with a MAC consisting of four octets of zeros. ...</t>
      </section>

      <section title="NEW: 9.2. Peer Process Operations">
	<t>...</t>
	<t>FXMIT. ... This message includes the normal NTP header data shown
	  in Figure 8, but with a MAC consisting of four octets of zeros.
	  This can be a legacy MAC or a MAC-EF.  If it's a MAC-EF, the
	  crypto-NAK MUST be the only MAC in the MAC-EF payload.  ...</t>
      </section>
    </section>

<!--
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>The author wishes to acknowledge the contributions of Joey
      Saccadonuts.</t>
    </section>
-->

    <!-- Possibly a 'Contributors' section ... -->

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo requests IANA to allocate the following bits in the NTP
	Extension Field Types table:
	<list>
	  <t>0x8000: R: Response (0: Request, 1: Response)</t>
	  <t>0x4000: E: Error (0: OK, 1: Error)</t>
	  <t>0x2000: O: MAC Optional (0: MAC required, 1: MAC optional)</t>
	  <t>0x1000: I: MAC Included (0: MAC not included, 1: MAC included)</t>
	</list>
      </t>

      <t>The following table should be the same as the existing NTP
      Extension Field Table, reformatted to account for the new flag
      bits.</t>
 
      <t><figure title="Current Extension Field Allocations">
          <artwork name="Current Extension Field Allocations"><![CDATA[
 0           1
 0123 4567 89012345   What:
+----+----+--------+
|REOI|Code|  Type  |
+----+----+--------+
|0000|  0 |     0  |  crypto-NAK (with Field Length of 0)
|    |    |     0  |  RESERVED: Permanently Unassigned
+----+----+--------+
|    |    |     1  |  RESERVED: Unassigned
+----+----+--------+
|0000|  0 |     2  |  Autokey: No-Operation Request
|1000|  0 |     2  |  Autokey: No-Operation Response
|1100|  0 |     2  |  Autokey: No-Operation Error Response
+----+----+--------+
|0000|  1 |     2  |  Autokey: Association Message Request
|1000|  1 |     2  |  Autokey: Association Message Response
|1100|  1 |     2  |  Autokey: Association Message Error Response
+----+----+--------+
|0000|  2 |     2  |  Autokey: Certificate Message Request
|1000|  2 |     2  |  Autokey: Certificate Message Response
|1100|  2 |     2  |  Autokey: Certificate Message Error Response
+----+----+--------+
|0000|  3 |     2  |  Autokey: Cookie Message Request
|1000|  3 |     2  |  Autokey: Cookie Message Response
|1100|  3 |     2  |  Autokey: Cookie Message Error Response
+----+----+--------+
|0000|  4 |     2  |  Autokey: Autokey Message Request
|1000|  4 |     2  |  Autokey: Autokey Message Response
|1100|  4 |     2  |  Autokey: Autokey Message Error Response
+----+----+--------+
|0000|  5 |     2  |  Autokey: Leapseconds Value Message Request
|1000|  5 |     2  |  Autokey: Leapseconds Value Message Response
|1100|  5 |     2  |  Autokey: Leapseconds Value Message Error Response
+----+----+--------+
|0000|  6 |     2  |  Autokey: Sign Message Request
|1000|  6 |     2  |  Autokey: Sign Message Response
|1100|  6 |     2  |  Autokey: Sign Message Error Response
+----+----+--------+
|0000|  7 |     2  |  Autokey: IFF Identity Message Request
|1000|  7 |     2  |  Autokey: IFF Identity Message Response
|1100|  7 |     2  |  Autokey: IFF Identity Message Error Response
+----+----+--------+
|0000|  8 |     2  |  Autokey: GQ Identity Message Request
|1000|  8 |     2  |  Autokey: GQ Identity Message Response
|1100|  8 |     2  |  Autokey: GQ Identity Message Error Response
+----+----+--------+
|0000|  9 |     2  |  Autokey: MV Identity Message Request
|1000|  9 |     2  |  Autokey: MV Identity Message Response
|1100|  9 |     2  |  Autokey: MV Identity Message Error Response
+----+----+--------+
|0010|  0 |     5  |  Checksum Complement
+----+----+--------+
]]></artwork>
        </figure></t>
      <t>Where the following Field Type flags are defined:
      <list>
	<t> R: 0 for a "Query", 1 for a "Response"</t>
	<t> E: 0 for "OK", 1 for an "Error"</t>
	<t> O: 0 for "MAC Required", 1 for "MAC Optional"</t>
	<t> I: 0 for "MAC Not Included", 1 for "MAC Included"</t>
      </list></t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Additional information TBD</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC2119;

      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml"?-->

      &RFC5905;

      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5906.xml"?-->

      &RFC5906;

      &RFC7821;
    </references>

    <!-- Here we use entities that we defined at the beginning. -->

    <!-- SW: Except that we're not really using these...

    <references title="Informative References">
      &RFC3552;

      &I-D.narten-iana-considerations-rfc2434bis;
 
    </references> 
     -->

    <!--
    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>
-->

    <!-- Change Log

v02 2016-10-29  HMS: Updates
v03 2018-08-21	HMS: Updates
                                                                                        -->
  </back>
</rfc>
